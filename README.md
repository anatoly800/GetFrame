# GetFrame

Техзадание: Извлечение кадра из видео и сохранение в PNG

Приложение для Android (реализация UI на Avalonia .NET 8/9) 

Функционал: Выбрать видео (MP4 и другие контейнеры по возможности), выбрать номер кадра и показать превью, сохранить кадр в PNG.  Язык  интерфейса и сообщений Английский.

Интерфейс

Делим окно приложения на части < Grid RowDefinitions="Auto, *, Auto" >

Использовать для блоков закруглённые рамки <Border Grid.Row="0" Classes="RoundedBorder"…

Grid.Row="0": иконка (кнопка) Open, Поле ввода номера кадра, иконка (кнопка) Save.

После открытия видео, поле автоматически устанавливается в номер последнего кадра.

Поведение поля ввода: задержка применения (debounce) 800 мс, чтобы избежать хаотичных обновлений при вводе.

Grid.Row="1": область превью извлекаемого кадра. Превью сохраняет аспект.

Grid.Row="2": 

В обычном состоянии отображает TextBlock содержащий:

1) Со старта: “Idle”

2) После открытия файла:  WxH (Размер кадра), HH:MM:SS.frame (длительность ), Frames [xxx] так же, дописываем после этих данных информацию если случились ошибки. Бордюр красим в красный цвет. Не забывать возвращать исходный цвет темы после успешного открытия нового файла.

3) Для тяжёлых операций открытия/извлечения - TextBlock прячем и отображаем широкую кнопку Cancel с анимированной заливкой. Анимация успокоит пользователя. Для убедительности отображаем “еlapsed” время в секундах (с точностью до сотых, без надписи еlapsed, просто секунды).  По завершении операции прячем кнопку Cancel и отображаем TextBlock.

Функциональные требования

Открыть файл: выбрать локальный файл; поддержка MP4 (минимум h264, другие по возможности)

Получить метаданные: длительность, количество кадров (если доступно), FPS, разрешение, кодек.

Установка номера кадра: при открытии — значение последнего кадра (или кадр, соответствующий последней миллисекунде).

Извлечение кадра: по номеру кадра или по времени; автоматически извлечь и отобразить превью после изменения в поле ввода кадра.

Сохранение: экспорт выбранного кадра в PNG с сохранением исходного соотношения сторон.

Поддержка форматов: MP4 обязателен; другие контейнеры — по возможности (зависит от используемой библиотеки).

UI остаётся отзывчивым: все тяжёлые операции в фоне и возможность отмены.

Рекомендации.

Для реализации работы с видео через **MediaMetadataRetriever** в приложении на Avalonia UI (.NET 8/9) рекомендуется использовать архитектурный паттерн «Сервис» (Service Pattern), чтобы разделить логику UI и специфичный для Android код.

Ниже приведены рекомендации по пунктам для организации этого процесса.

### 1. Архитектурная организация (Service Pattern)

Так как Avalonia — кроссплатформенная среда, нативный код Android нельзя писать напрямую в общем проекте.

* **В общем проекте (Shared):** Создайте интерфейс, например `IVideoService`, с методами `GetVideoInfo(string path)` и `GetFrame(string path, double positionPercent)`.
* **В Android-проекте:** Реализуйте этот интерфейс, используя классы из пространства имен `Android.Media`.
* **Регистрация:** При старте приложения в `MainActivity.cs` зарегистрируйте реализацию через статический доступ или Dependency Injection.

### 2. Инициализация и получение общих метаданных

Для всех версий Android процесс начинается одинаково:

1. Создайте экземпляр: `var retriever = new MediaMetadataRetriever();`. 


2. Установите источник: `retriever.SetDataSource(filePath);`.
3. Извлеките базовые данные (размеры и длительность):
* **Ширина/Высота:** Ключи `MetadataKeyVideoWidth` и `MetadataKeyVideoHeight`.
* **Длительность:** Ключ `MetadataKeyDuration` (возвращает строку в **миллисекундах**). 


### 3. Рекомендации для API менее 28 (Android < 9.0)

На старых версиях возможности ограничены:

* **Число кадров:** Прямого ключа нет. Единственный надежный способ — расчетное значение: .
* **FPS:** Используйте ключ `MetadataKeyCaptureFramerate`. Обратите внимание, что он может вернуть `null` Для таких случаев прерываем работу с ошибкой. 


* **Извлечение кадра:** Используйте `GetFrameAtTime(long timeUs, Option option)`. 


* **Важно:** Время передается в **микросекундах** ().
* Для последнего кадра: передавайте `(durationMs * 1000) - 1` с флагом `OptionClosest`.
* У нас нет приоритета в скорости поэтому использование `OptionClosest` нас устраивает. 





### 4. Рекомендации для API 28 и выше (Android 9.0+)

Начиная с API 28, работа становится точнее и быстрее:

* **Число кадров:** Используйте специальный ключ **`MetadataKeyVideoFrameCount`**. Он возвращает точное количество кадров в файле. 


* **Извлечение кадра:** Вместо времени используйте метод **`GetFrameAtIndex(int frameIndex)`**. 


* Для последнего кадра: вызывайте `GetFrameAtIndex(totalFrames - 1)`.
* Это работает быстрее и стабильнее, так как исключает ошибки округления при расчете времени в микросекундах.



### 5. Конвертация в формат Avalonia

Метод `GetFrame...` возвращает `Android.Graphics.Bitmap`. Чтобы отобразить его в Avalonia UI, выполните конвертацию через поток :

```csharp
// 1. Сохраняем нативный битмап в поток (PNG/JPEG)
using var stream = new MemoryStream();
nativeBitmap.Compress(Android.Graphics.Bitmap.CompressFormat.Png, 100, stream);
stream.Position = 0;

// 2. Создаем битмап Avalonia
var avaloniaBitmap = new Avalonia.Media.Imaging.Bitmap(stream);

// 3. Не забываем освободить нативный ресурс
nativeBitmap.Recycle();
nativeBitmap.Dispose();

```

### 6. Оптимизация производительности

* **Асинхронность:** Всегда вызывайте методы `MediaMetadataRetriever` в фоновом потоке (например, через `Task.Run`), так как декодирование кадра (особенно последнего) — тяжелая операция, которая заблокирует UI. 


* **Превью (Thumbnails):** используйте `GetScaledFrameAtTime` — это значительно экономит оперативную память мобильного устройства. 


* **Очистка:** Обязательно вызывайте `retriever.Release()` и `retriever.Dispose()` после завершения работы, иначе возникнут утечки памяти в нативной части Android.

Проект содержит файл `setup.sh` для автоматической настройки окружения.
